// function foo(x, y) {
//   console.log(x, y);
//   return x + y;
// }

// console.log(foo(1));

// const add = (x, y) => x + y;
// console.log(add(1, 2));
// console.log(add("1", 2));

// const double = (x) => x * 2;

// console.log(double(4));
// console.log(double("4"));

// const assoc = (key, value, obj) => {
//   obj[key] = value;
// };

// const person = {
//   name: "Bobo",
//   description: "A person",
// };

// const result = assoc("something", 500, person);

// console.log({
//   person,
//   result,
// });

// async function process(item) {
//   //pretend this is a long running async task
//   return item * 2;
// }

// const a = [1, 2, 3, 4, 5];

// // const result = [];
// // a.forEach(async (item) => {
// //   result.push(await process(item));
// // });

// const result = a.map(async (item) => {
//   return await process(item);
// });

// console.log(result);

// You have a simple React single page app, which is built using Webpack behind the scenes. A new production build was just run after a PR was approved, and you get the following files as a result (the hashes are autogenerated by Webpack, and index.html is dynamic as well):

// index.html
// bundle.83n09s2.js
// vendors.yye21iu.js
// style.p0974ah.css

// Now when your users go to your site all they see is a blank page, and the DevTools console shows the following error message:

// Uncaught SyntaxError: Unexpected token '<'

// What is the most likely cause of this error?

// Create a dedupe function which takes an array of Object instances and returns a new array with no items that have the same item.id value, but if there's any duplicate items the data for them should be merged into a single object. All of this keeping the original array's order as closely as possible (see the test case for an example of the expected output).

// const dedupe = (arr) => {
//   const result = [];
//   const ids = [];
//   arr.forEach((item) => {
//     if (!ids.includes(item.id)) {
//       ids.push(item.id);
//       result.push(item);
//     } else {
//       const index = ids.indexOf(item.id);
//       result[index] = { ...result[index], ...item };
//     }
//   });
//   return result;
// };

// Your JS-based app needs to make two requests to an external API to fecth two sets of tada: customers and orders. Due to how you'll need to use this data, a good strategy is to match and merge the two lists into one: a list of customers where each item can have a nested list of orders.

// Build a denormalize function which takes in two arrays and the reference ID (foreign key), the first one being the primary type (in this case denormalize(customers, orders, 'customerId'), and returns a new array with the nested structure described above.

// const denormalize = (primary, related, relatedName, referenceId) => {
//   const result = [];
//   primary.forEach((item) => {
//     const newItem = { ...item };
//     newItem[relatedName] = related.filter(
//       (relatedItem) => relatedItem[referenceId] === item.id
//     );
//     result.push(newItem);
//   });
//   return result;
// };

// q: is the following code a pure function?
// const assoc = (key,value,object) => {
//   object[key] = value;
// }

// a: no, because it mutates the object passed in

// q: Given the following code.
// const D = C => ({children}) => (
// <div>
// <span>Foo</span>
// <C>{children}</C>
// </div>
// )
// const MyClass = ({children}) => <span>{children}</span>
// const X = D(MyClass, "world")
// what will be the output of the jsx <X>Hello</X> when it is rendered?

// a: <div><span>Foo</span><span>Hello</span></div>

// q: Given the following array:

// async function process(item) {
//   //pretend this is a long running async task
//   return item * 2;
// }

// const a = [1, 2, 3, 4, 5];

// Which of the following will result in the array [2, 4, 6, 8, 10]?
// regardless of the order of the items in the array

// a: const result = a.map(async (item) => {
//   return await process(item);
// });

// q: After deploying the first version of your app to the Web, when you go to your live website you see lots of error messages and stuck loaders. After looking at the Developer Tools tab in your browser, you see a few error messages that look like this:

// Access to fetch at 'https://api.example.com/users' from origin 'https://example.com' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource.

// What should be done to fix this issue, given your app is using the Fetch API to make those requests?

// find the correct option:

// a: We should axios instead of fetch
// b: The Backend has to allow OPTIONS requests from our app's domain
// c: The client needs to call fetch with mode: 'no-cors'
// d: We should use regular .then calls instead of async/await

// // q: Given the following component:

// const UserCard = ({name}) => {
//   const updateCount = React.useRef(0);
//   const [enabled, setEnabled] = React.useState(true);

//   React.useEffect(()=>{
//     updateCount.current++;
//   },[enabled])

//   React.useEffect(()=>{
//     updateCount.current++;
//   },[updateCount.current])

//   console.log(updateCount.current)

//   return (
//     <div>
//       <h2>{name}</h2>
//       <button onClick={()=>setEnabled(!enabled)}>
//         {enabled ? 'Disable' : 'Enable'}
//       </button>
//     </div>
//   )
// }
// Assuming no extarnal factors that could lead to rerenders, what is printed to the console after you click the button for the fifth time?

// a: 5
